function [xs,ys,zs,RC] = genscat(roidim,meandist,I,g)

%GENSCAT   Generate a distribution of scatterers
%   [XS,YS,ZS] = GENSCAT([WIDTH HEIGHT],MEANDIST) generates a 2-D
%   pseudorandom distribution of scatterers such that the mean distance
%   between a scatterer and its nearest neighbor is approximately MEANDIST.
%   The vector [WIDTH HEIGHT] (unit = m) specifies the width and height of
%   the rectangular ROI to which the scatterers belong. The middle of its
%   lower edge (in the x-z coordinate system) is located at (0,0). In this
%   2-D syntax, YS is a vector of zeros.
%
%   [XS,YS,ZS] = GENSCAT([WIDTH HEIGHT DEPTH],MEANDIST) generates a 3-D
%   pseudorandom distribution of scatterers such that the mean distance
%   between a scatterer and its nearest neighbor is approximately MEANDIST.
%   The vector [WIDTH HEIGHT DEPTH] (unit = m) specifies the width
%   (x-direction), height (z-direction), and depth (y-direction) of the ROI
%   box to which the scatterers belong. The center of its lower face (in
%   the x-y-z coordinate system) is located at (0,0,0).
%
%   [XS,YS,ZS,RC] = GENSCAT([...],MEANDIST,I) also returns the reflection
%   coefficients RC of the scatterers. The RC values follow Rayleigh
%   distributions whose means are calculated from the image I. I must be a
%   2-D or 3-D image whose size is given by [WIDTH HEIGHT] (2-D) or
%   [WIDTH HEIGHT DEPTH] (3-D).
%
%   If a 2-D image I is given as an input, you can use [WIDTH NaN] or
%   [Nan HEIGHT]. The missing value is calculated from the size of the
%   image I while preserving the aspect ratio. Similarly, [WIDTH Nan NaN],
%   [Nan HEIGHT NaN], or [NaN NaN DEPTH] can be used with a 3-D image. If I
%   is empty or omitted, then I is assumed to be ones([WIDTH HEIGHT]) in
%   2-D, or ones([WIDTH HEIGHT DEPTH]) in 3-D.
%
%   [...] = GENSCAT(...,G) assumes that the dynamic range of the input
%   image I is G dB (defaut value = 40 dB). If G<=1, it is assumed that the
%   image I was gamma-compressed, with gamma = G.
%
%   Note on MEANDIST:
%   ---------------- 
%   We recommend a MEANDIST value less than or equal to the minimum
%   wavelength (at -6 dB). For a speed of sound c, from the PARAM structure
%   generated by GETPARAM, you may use
%       MEANDIST = PARAM.c/(PARAM.fc*(1+PARAM.bandwidth/200)),
%   or a smaller value. This value is used automatically if you input the
%   PARAM structure instead of MEANDIST:
%       [...] = GENSCAT([...],PARAM,I)
%   Note: by default, PARAM.c = 1540 [m/s] and PARAM.bandwidth = 75 [%],
%   as in PFIELD.
%
%
%   Example: cardiac scatterers:
%   ---------------------------
%   %-- Read the heart image and make it gray
%   I = imread('heart.jpg');
%   I = rgb2gray(I);
%   [nl,nc] = size(I);
%   %-- Parameters of the cardiac phased array
%   param = getparam('P4-2v');
%   %-- Pseudorandom distribution of scatterers (depth is 15 cm)
%   [xs,~,zs,RC] = genscat([NaN 15e-2],param,I);
%   %-- Display the scatterers in a dB scale
%   scatter(xs*1e2,zs*1e2,2,20*log10(RC/max(RC(:))),'filled')
%   caxis([-40 0])
%   colormap hot
%   axis equal ij tight
%   set(gca,'XColor','none','box','off')
%   title([int2str(numel(RC)) ' cardiac scatterers'])
%   ylabel('[cm]')
%   
%   
%   This function is part of MUST (Matlab UltraSound Toolbox).
%   MUST (c) 2020 Damien Garcia, LGPL-3.0-or-later
%
%   See also SIMUS, GETPARAM.
%
%   -- Damien Garcia -- 2021/12, last update 2022/02/25
%   website: <a
%   href="matlab:web('http://www.biomecardio.com')">www.BiomeCardio.com</a>


%-- Check the input arguments
assert(nargin>1 && nargin<5,'GENSCAT must have 2 to 4 input arguments.')
assert(nargout<5,'Too many output arguments.')
assert(isnumeric(roidim) && isvector(roidim),...
    'The 1st argument must be a numeric vector.')
assert(length(roidim)==2 || length(roidim)==3,...
    'The 1st argument must be a vector of length 2 or 3.')
if isstruct(meandist)
    %-- The input is PARAM
    % Check the PARAM structure and calculate the default MEANDIST
    % (= minimal wavelength at -6 dB)
    param = meandist;
    %--
    % 1) Center frequency (in Hz)
    assert(isfield(param,'fc'),...
        'A center frequency value (PARAM.fc) is required.')
    %--
    % 2) Fractional bandwidth at -6dB (in %)
    if ~isfield(param,'bandwidth')
        param.bandwidth = 75;
    end
    assert(param.bandwidth>0 && param.bandwidth<200,...
        'The fractional bandwidth at -6 dB (PARAM.bandwidth, in %) must be in ]0,200[')
    %--
    % 3) Longitudinal velocity (in m/s)
    if ~isfield(param,'c')
        param.c = 1540; % default value
    end
    %--
    meandist = param.c/(param.fc*(1+param.bandwidth/200));
else
    assert(isnumeric(meandist) && isscalar(meandist) && meandist>0,...
        'MEANDIST must be a positive scalar.')
end
if nargin>2
    assert(ismember(ndims(I),[2 3]) && all(I(:)>=0),...
        'I must be 2-D or 3-D with non-negative elements.')
    assert(length(roidim)==ndims(I),...
        'The number of dimensions of I does not match the length of the 1st argument.')
else
    assert(all(isfinite(roidim)),...
        'The 1st argument must contain only finite elements if I is not given.')
end


%-- Calculate xmin, xmax, ymin, ymax, and zmax (we have zmin = 0)
width = roidim(1); height = roidim(2);
%
if length(roidim)==2 % 2-D
    assert(nnz(isfinite(roidim))>0,...
        'The vector [WIDTH HEIGHT] must contain at least one finite element.')
    if nargin>2 % I is given
        [m,n] = size(I);
        if ~isfinite(width), width = n*height/m; end
        if ~isfinite(height), height = m*width/n; end
    end
else % 3-D
    tmp = nnz(isfinite(roidim)); assert(tmp==1 || tmp==3,...
        'The vector [WIDTH HEIGHT DEPTH] must contain one or three finite elements.')
    depth = roidim(3); 
    if nargin>2 % I is given
        [m,n,p] = size(I);
        if any(~isfinite(roidim)) % [WIDTH HEIGHT DEPTH] contains NaN or Inf
            if isfinite(height)
                width = n*height/m;
                depth = p*height/m;
            elseif isfinite(width)
                height = m*width/n;
                depth = p*width/n;
            else
                width = n*depth/p;
                height = m*depth/p;
            end
        end
    end
    ymin = -depth/2; ymax = depth/2; 
end
%
xmin = -width/2;
xmax = width/2;
zmin = 0;
zmax = height;


%-- Pseudorandom distribution of the scatterers
if length(roidim)==2 % 2-D
    %-- 2-D pseudorandom distribution --
    
    xz_inc = meandist/sqrt(2/5);
    % note: sqrt(2/5) was determined numerically (theory = ?...)
    
    [xs,zs] = meshgrid(xmin:xz_inc:xmax,zmin:xz_inc:zmax);
    xs = xs + rand(size(xs))*xz_inc-xz_inc/2;
    zs = zs + rand(size(zs))*xz_inc-xz_inc/2;
    
    idx = xs>xmin & xs<xmax & zs>zmin & zs<zmax;
    xs = xs(idx); zs = zs(idx);
    ys = zeros(size(xs));

else % 3-D
    %-- 3-D pseudorandom distribution --
    
    xyz_inc = meandist/sqrt(16/39);
    % note: sqrt(16/39) was determined numerically (theory = ?...)
    
    [xs,ys,zs] = meshgrid(xmin:xyz_inc:xmax,...
        ymin:xyz_inc:ymax,zmin:xyz_inc:zmax);
    xs = xs + rand(size(xs))*xyz_inc-xyz_inc/2;
    ys = ys + rand(size(ys))*xyz_inc-xyz_inc/2;
    zs = zs + rand(size(zs))*xyz_inc-xyz_inc/2;
    
    idx = xs>xmin & xs<xmax & ys>ymin & ys<ymax & zs>zmin & zs<zmax;
    xs = xs(idx); ys = ys(idx); zs = zs(idx);
    
end
    
xs = xs(:); ys = ys(:); zs = zs(:);


%-- If no I: the reflection coefficients follow a Rayleigh
%            distribution of mean 1
if nargin<3 || isempty(I)
    RC = raylrnd(1,1,length(xs))'/sqrt(pi/2);
    return
end


I = double(I);
I = I/max(I(:));


%-- Image grid
if length(roidim)==2
    %-- 2-D image grid
    assert(ismatrix(I),['Number of dimensions of I ',...
        'is not consistent with the first input vector.'])
    [nl,nc] = size(I);
    dxi = (xmax-xmin)/nc;
    dzi = (zmax-zmin)/nl;
    [xi,zi] = meshgrid(linspace(xmin+dxi/2,xmax-dxi/2,nc),...
        linspace(zmin+dzi/2,zmax-dzi/2,nl));
    
elseif length(roidim)==3
    %-- 3-D image grid    
    assert(ndims(I)==3,['Number of dimensions of I ',...
        'is not consistent with the first input vector.'])
    [nl,nc,np] = size(I);
    dxi = (xmax-xmin)/nc;
    dyi = (ymax-ymin)/np;
    dzi = (zmax-zmin)/nl;
    [xi,zi,yi] = meshgrid(linspace(xmin+dxi/2,xmax-dxi/2,nc),...
        linspace(zmin+dzi/2,zmax-dzi/2,nl),...
        linspace(ymin+dyi/2,ymax-dyi/2,np));    
end


%-- Reflection coefficients calculated from the image
if nargin<4
    g = 40; % default value for log compression
end
if length(roidim)==2
    RC = interp2(xi,zi,I,xs,zs,'linear',0);
elseif length(roidim)==3
    RC = interp3(xi,zi,yi,I,xs,zs,ys,'linear',0);
end
if g>1
    % log compression
    RC = 10.^(g/20*(RC-1));
else
    % gamma compression
    RC = RC.^(1/g);
end
% add some randomness in the reflection coefficients
RC = RC.*raylrnd(1,1,length(xs))'/sqrt(pi/2);    

